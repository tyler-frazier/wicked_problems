<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Spatial Population Modelling - Population and Development Data Science</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="book.html">About this book</a></li><li class="expanded affix "><a href="author.html">About the author</a></li><li class="expanded "><a href="courses.html"><strong aria-hidden="true">1.</strong> Teaching and Syllabuses</a></li><li><ol class="section"><li class="expanded "><a href="expect.html"><strong aria-hidden="true">1.1.</strong> Expectations and Assessment</a></li><li class="expanded "><a href="data310.html"><strong aria-hidden="true">1.2.</strong> DATA 310 Applied Machine Learning</a></li><li class="expanded "><a href="data441.html"><strong aria-hidden="true">1.3.</strong> DATA 441 Agent-Based Modeling</a></li><li class="expanded "><a href="data150.html"><strong aria-hidden="true">1.4.</strong> DATA 150 Evolving Solutions</a></li><li class="expanded "><a href="data100.html"><strong aria-hidden="true">1.5.</strong> DATA 100 Wicked Problems</a></li></ol></li><li class="expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Student Preparations</a></li><li><ol class="section"><li class="expanded "><a href="gitstart.html"><strong aria-hidden="true">2.1.</strong> Getting Started with GitHub</a></li><li class="expanded "><a href="rstart.html"><strong aria-hidden="true">2.2.</strong> Getting Started with R &amp; RStudio</a></li><li class="expanded "><a href="jupyterstart.html"><strong aria-hidden="true">2.3.</strong> Getting Started with JupyterHub</a></li><li class="expanded "><a href="colabstart.html"><strong aria-hidden="true">2.4.</strong> Getting Started with Google Colab</a></li></ol></li><li class="expanded "><a href="datause.html"><strong aria-hidden="true">3.</strong> Data Use for Human and Community Scale Processes</a></li><li><ol class="section"><li class="expanded "><a href="describe.html"><strong aria-hidden="true">3.1.</strong> Spatial Population Description</a></li><li class="expanded "><a href="model.html" class="active"><strong aria-hidden="true">3.2.</strong> Spatial Population Modelling</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Population and Development Data Science</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Regress the data from two variables against each other and examine the coorelationship that is being described by the two variables.  Use the <code>geom_point()</code> command to add the points for your two variables as well as the <code>geom_smooth()</code> command to add the regression line (as well as the confidence interval).</p>
<pre><code class="language-r">ggplot(lbr_adm2, aes(pop19, ntl)) + 
  geom_point(size = .1, color = &quot;red&quot;) +
  geom_smooth()
</code></pre>
<p><img src="images/popntl.png" alt="" /></p>
<p>Estimate the parameters of your model using the <code>lm()</code> command and then return a <code>summary()</code> to find out more information regarding the model's fit and capacity to explain the coorelationship between your two selected variables.</p>
<pre><code class="language-r">fit &lt;- lm(pop19 ~ ntl, data=lbr_adm2)
summary(fit)
</code></pre>
<p><img src="images/screen-shot-2019-09-30-at-12.47.52-am%20%281%29.png" alt="" /></p>
<p>Add a few more variables to the <code>lm()</code> command.  For example in the following plot I have estimated a regression model where the population of Liberia in 2019 is the dependent variable (response), while night time lights (<code>ntl</code>), urban cover (<code>dst190</code>), and bare cover (<code>dst200</code>) are the independent variables (predictors).</p>
<pre><code class="language-r">ggplot(lm(pop19 ~ ntl + dst190 + dst200, data=lbr_adm2)) + 
  geom_point(aes(x=.fitted, y=.resid), size = .1) +
  geom_smooth(aes(x=.fitted, y=.resid))
</code></pre>
<p><img src="images/popntlurbbare.png" alt="" /></p>
<p>Again estimate the model and check the fit.</p>
<pre><code class="language-r">fit &lt;- lm(pop19 ~ ntl + dst190 + dst200, data=lbr_adm2)
summary(fit)
</code></pre>
<p><img src="images/screen-shot-2019-09-30-at-1.06.19-am.png" alt="" /></p>
<p>Finally, add all of the variables to your regression model.  Compare the results.</p>
<pre><code class="language-r">ggplot(lm(pop19 ~ water + dst011 + dst040 + dst130 + dst140 + dst150 + dst160 + dst190 + dst200 + topo + slope + ntl, data=lbr_adm2)) + 
  geom_point(aes(x=.fitted, y=.resid), size = .1) +
  geom_smooth(aes(x=.fitted, y=.resid))
</code></pre>
<p><img src="images/all.png" alt="" /></p>
<pre><code class="language-r">fit &lt;- lm(pop19 ~ water + dst011 + dst040 + dst130 + dst140 + dst150 + dst160 + dst190 + dst200 + topo + slope + ntl, data=lbr_adm2)
summary(fit)
</code></pre>
<p><img src="images/screen-shot-2019-09-30-at-1.10.44-am.png" alt="" /></p>
<h2><a class="header" href="#team-challenge-question" id="team-challenge-question">Team Challenge Question</a></h2>
<p>Also use <code>ggplot()</code> to plot <strong>two linear models</strong>.  Use the <code>fit()</code> and <code>summary()</code> commands to describe your models.  Are you able to definitively identify coorelation between population and any of the other or combination of other land use and land cover geospatial covariates?  How about density?</p>
<p>Meet with your group and prepare four different plots from at least three different countries (or team members) for the Friday informal group presentation.  Then as a group, upload all 5 team members plots to #data100_igps (informal group presentations) by Sunday night.  Each member should upload at least <strong>two combined histogram / density plots</strong> as well as <strong>two linear model plots</strong>.</p>
<h2><a class="header" href="#individual-stretch-goal-1" id="individual-stretch-goal-1">Individual Stretch Goal 1</a></h2>
<p>Manually recreate the <code>ggplot()</code> model of your regression from above.  First identify the <code>fitted.values</code> as a variable in the model you named <code>fit.</code>  Use the <code>$</code> operator to identify the variable within the model object and return all of the values.</p>
<pre><code class="language-r">name_of_model$variable.with.fitted.values
</code></pre>
<p>Send this <code>object$variable</code> directly to the console and review the results.  You should have the same number of fitted values as subdivisions within your adm2.  Each individual fitted value is calculated by multiplying each variables' estimate (or coefficient) by the actual value for that observation (or row) and then summating the total of those products.</p>
<p>Likewise, manually calculate each individual model residual by subtracting all of the values for the dependent or response variable, <code>pop19</code>, from each cooresponding calculated, fitted value.  The difference of these two outcomes are the model residuals.</p>
<pre><code class="language-r">your_adm2$pop19 - name_of_model$variable.with.fitted.values
</code></pre>
<p>Plot the two variables as a <code>ggplot</code> object.  First create a <code>data.frame</code> using the <code>cbind.data.frame()</code> command.  Name each of the new columns within your data frame accordingly.</p>
<pre><code class="language-r">model_data &lt;- cbind.data.frame(fitted = name_of_model$variable.with.fitted.values, residuals = your_adm2$pop19 - name_of_model$variable.with.fitted.values)
</code></pre>
<p>Use <code>ggplot()</code> to plot your model.</p>
<pre><code class="language-r">ggplot(data = you_data_frame, aes(x = variable, y = variable)) +
  geom_point(size = 0.25) +
  geom_smooth(size = 0.5)
</code></pre>
<p><img src="images/plot%20%281%29.png" alt="" /></p>
<p>The three observations beneath the curve before it begins to rise seem to evidence the final contributions to the model before it transitions towards the observation for Monrovia.  Add labels to these four points, by using the <code>subset()</code> command and creating a new object that you will use to annotate each of those four observations.</p>
<pre><code class="language-r">text &lt;- subset(model_data, fitted &gt; add_value_here)
</code></pre>
<p>Use this new object to plot the names of these four observations from the data.</p>
<pre><code class="language-r">ggplot(data = your_data, aes(x = variable, y = variable)) +
  geom_point(size = 0.25) +
  geom_smooth(size = 0.5) +
  geom_text(data = your_data,
            aes(x = variable,
                y = variable,
                label = name),
            size = 2,
            nudge_y = value)
</code></pre>
<p><img src="images/plot.png" alt="" /></p>
<p>Likewise manually calculate residual standard error.</p>
<pre><code class="language-r">#How to calculate Residual Standard error (Like Standard Deviation)
k &lt;- length(fit$coefficients)-1 #Subtract one to ignore intercept
SSE &lt;- sum(fit$residuals^2)
n &lt;- length(fit$residuals)
#Residual Standard Error
sqrt(SSE/(n-(1+k)))
</code></pre>
<p>Also, manually calculate multiple R^2.</p>
<pre><code class="language-text">#Multiple R-Squared (Coefficient of Determination)
SSyy &lt;- sum((lbr_adm2$pop19 - mean(lbr_adm2$pop19))^2)
SSE &lt;- sum(fit$residuals^2)
(SSyy-SSE)/SSyy
#Alternatively
1-SSE/SSyy
</code></pre>
<p>Calculate adjusted R^2.</p>
<pre><code class="language-r">#Adjusted R-Squared
n &lt;- length(lbr_adm2$pop19)
k &lt;- length(fit$coefficients)-1
SSE &lt;- sum(fit$residuals^2)
SSyy = sum((lbr_adm2$pop19 - mean(lbr_adm2$pop19))^2)
1-(SSE/SSyy)*(n-1)/(n-(k+1))
</code></pre>
<p>Calculate the F-statistic.</p>
<pre><code class="language-r">#F-Statistic
((SSyy-SSE)/k) / (SSE/(n-(k+1)))
</code></pre>
<p>Finally, manually add the adjusted R^2 and F-statistic as labels to your plot.</p>
<pre><code class="language-r">ggplot(data = model_data, aes(x = fitted, y = residuals)) +
  geom_point(size = 0.25) +
  geom_smooth(size = 0.5) +
  geom_text(data = text,
            aes(x = fitted,
                y = residuals,
                label = adm1),
            size = 2,
            nudge_y = 7500) +
  geom_text(aes(x = 500000,
                y = 25000,
                label = &quot;Adjusted R-Squared&quot;)) +
  geom_text(aes(x = 500000,
                y = 0,
                label = round(as.numeric(summary(fit)[9]), 4))) +
  geom_text(aes(x = 500000,
                y = -40000,
                label = &quot;F-statistic&quot;)) +
  geom_text(aes(x = 500000,
                y = -65000,
                label = round(as.numeric(summary(fit)[[10]][1]), 4)))
</code></pre>
<p><img src="images/plot%20%282%29.png" alt="" /></p>
<h1><a class="header" href="#modeling--predicting-spatial-values" id="modeling--predicting-spatial-values">Modeling &amp; Predicting Spatial Values</a></h1>
<p>In this lab, you will use the model parameters your previously estimated in order to predict spatial values across the landscape of your selected LMIC.  To do this create a new script, install and load needed packages and libraries, and set your working directory.  Once you have your script set up with <code>sf::</code> , <code>raster::</code>, <code>tidyverse::</code>, <code>doParallel::</code>, and <code>snow::</code> all in place, again load your <code>RasterStack</code> into your RStudio workspace.  I named my 12 layer <code>RasterStack</code> that describes land use and land cover throughout Liberia, <code>lulc</code>, and just as before it displays the following summary characteristics.</p>
<p><img src="images/screen-shot-2019-10-06-at-6.53.01-pm.png" alt="" /></p>
<p>Also, load the <code>adm0</code> (or international boundary), <code>adm1</code> and <code>adm2</code> for your LMIC.  If you don't have your international boundary, go back to GADM, HDX or also look on Geoboundaries for the shapefile in order to import to your RStudio work session.</p>
<p>{% embed url=&quot;https://www.gadm.org&quot; caption=&quot;Link to GADM&quot; %}</p>
<p>{% embed url=&quot;https://data.humdata.org&quot; caption=&quot;Link to HDX&quot; %}</p>
<p>{% embed url=&quot;http://www.geoboundaries.org/data/1_3_3/zip/shapefile/&quot; caption=&quot;Geoboundaries subdirectory with shapefiles by ISO code&quot; %}</p>
<p>For this exercise, I will retrieve my international border shapefile from the Geoboundaries subdirectory and then use the <code>read_sf()</code> command to import the data as an object I named <code>lbr_int</code>.</p>
<p>You will also need the WorldPop raster later in the exercise in order to calculate a basic estimate of spatial error.  To improve upon the predictive capability of the model, I have gone back and retrieved the 2015 WorldPop raster file of persons per pixel (ppp) for Liberia, rather than the 2019 population counts we previously used.  It is probably not going to have a huge impact, but if you want to try for the best results, the date value of your response variable should be the same as the date value of your geospatial covariates.</p>
<pre><code class="language-r">lbr_pop15 &lt;- raster(&quot;lbr_ppp_2015.tif&quot;)
</code></pre>
<p>You may have noticed when reviewing the characteristics of your <code>RasterStack</code> that many of the layers had <code>?</code> as the value for both the <code>min values</code> and <code>max values</code>.  The reason this occurred is because each of the layers within the <code>raster</code> is presenting values outside of the boundaries of our LMIC.  For example, with Liberia, you will notice that there is a large portion of the area within the plot but outside of the national border that has some assigned value (likely <code>NA</code>).  These values are not part of our analytical area and should be omitted.  In order to fix this problem, we need to use the <code>mask()</code> command to remove all of the gridcells that are not explicitly within the international border of our LMIC.</p>
<pre><code class="language-r">yourRasterStack &lt;- add_command_here(yourRasterStack, yourLMIC_intlborder)
</code></pre>
<p>It might take a few minutes to run the <code>mask()</code> command.  On a MBAir using the <code>mask()</code> command on a 12 layer <code>RasterStack</code> (each layer having about 25 million gridcells) it takes about 10 minutes.  Once the command is completed, you should now notice <code>min values</code> and <code>max values</code> when retrieving a summary of what has now been transformed from a <code>RasterStack</code> to a <code>RasterBrick</code>.</p>
<p><img src="images/screen-shot-2019-10-06-at-7.50.14-pm.png" alt="" /></p>
<p>As in the previous exercise, estimate your linear model using the <code>pop15</code> variable as your response (dependent variable) and all of the covariates from your <code>adm2</code> sf object as the predictors (independent variables).</p>
<pre><code class="language-r">model &lt;- add_command_here(depvar ~  ind1 + ... + indN, data=your_adm2_sf)
</code></pre>
<p>Once you have estimated your model, use the <code>summary()</code> command to review a summary of its characteristics.</p>
<p><img src="images/screen-shot-2019-10-06-at-8.23.25-pm.png" alt="" /></p>
<p>Confirm that each variable in your <code>lulc</code> object has a corresponding variable in the linear model you just estimated.  You will use these estimates with the 12 different geospatial coverariate layers within your <code>RasterBrick</code> to predict the population at each gridcell across your LMIC.  Use the <code>predict()</code> function from the <code>raster::</code> package with your <code>lulc</code> object as well as your <code>model</code> to predict the population value of every gridcell within the borders of your LMIC.</p>
<pre><code class="language-r">predicted_values &lt;- library::function(RasterBrick, your_model, progress=&quot;window&quot;)
</code></pre>
<p>Adding the <code>progress=&quot;window&quot;</code> argument at the end of the command should force a progress window to appear on main desktop that informs you of how many steps are needed to completely execute the command as well as how many have been completed.  The <code>progress=&quot;window&quot;</code> argument is purely optional.</p>
<p>The resulting object <code>predicted_values</code> should be a single <code>RasterLayer</code> with the same number of gridcells as each layer within your <code>RasterBrick</code>.   Type the name of the <code>RasterLayer</code> into the console to review its summary output, while also noting the minimum and maximum values across all gridcells.</p>
<p>Use the <code>cellStats(predicted_values, sum)</code> command to calculate the sum of all the values in every gridcell throughout your newly created <code>RasterLayer</code>.  With the model estimated for Liberia, the sum total of all predicted values is <code>113413402375</code>(113 billion).  Compared with the output from <code>sum(your_adm2$pop15)</code> (which is <code>4039128</code>for Liberia) your will very likely that your model has massively overestimated population values (in this case by an order of about 28,000 times).</p>
<p>While these predicted values are no where near the real population count at each gridcell, they do nonetheless provide a spatial description of the proportion of persons as distributed across the landscape of your LMIC.  In fact, if we execute some basic raster algebra and subtract the minimium value from my <code>predicted_values</code> <code>RasterLayer</code> and then sum the values of all gridcells, we will find that while the total population predicted is still very likely a gross overestimation, it is getting closer to our best estimate of the real value (in the case of Liberia, now an order of 15 times <code>pop15</code>).</p>
<pre><code class="language-r">base &lt;- predicted_values - minValue(predicted_values)
cellStats(base, sum) 
</code></pre>
<p>We will proceed with the <code>RasterLayer</code> by using the <code>extract()</code>command to assign the ID from each <code>adm2</code> object to each gridcell containing a predicted value from our linear model using the <code>lulc</code> geospatial covariates as indenpendent variables.  To effectively use the <code>extract()</code> command, set <code>ncores</code> object to one less than your total and then also execute the <code>beginCluster()</code> command as you have done in previous exercises.  In this case, since it is only one layer, the extract command should take less time to execute (about 10 to 15 minutes on an MBAir).</p>
<pre><code class="language-r">ncores &lt;- detectCores() - 1
beginCluster(ncores)
pred_vals_adm2 &lt;- raster::extract(your_pred_vals_raster, your_adm2, df=TRUE)
endCluster()
</code></pre>
<p>Once you have assigned the <code>ID</code> to each gridcell according to its <code>adm2</code> location, aggregate the values.  This time we will use a slightly different command to sum the values by <code>adm2</code> unit, although either way could work.  Also, bind this new column to your <code>adm2</code> <code>sf</code> object.</p>
<pre><code class="language-r">pred_ttls_adm2 &lt;- aggregate(. ~ ID, pred_vals_adm2, sum)
lbr_adm2 &lt;- bind_cols(lbr_adm2, pred_ttls_adm2)
</code></pre>
<p>Your <code>sf</code> object now has a new column named <code>layer</code> that has the sum of all predicted values for each <code>adm2</code> subdivision of the LMIC.  Assign the value for <code>layer</code> to each gridcell according to its <code>adm2</code> subdivision.  Use the <code>rasterize()</code> command with your <code>adm2</code> object and your <code>predicted_values</code> raster in order to create a new <code>raster</code> that has the predicted totals of every <code>adm2</code> assigned to each gridcell according to its location.  The <code>raster</code> object used in the argument (in this case <code>predicted_values</code>) is the base template for the new raster produced as a result of the command. </p>
<pre><code class="language-r">new_raster &lt;- command(adm2, template_raster, field = &quot;layer&quot;)
</code></pre>
<p>Create a new raster that represents each gridcells proportion of the total within its <code>adm2</code> subdivision.</p>
<pre><code class="language-r">another_new_raster  &lt;- raster_1 / raster_2
</code></pre>
<p>Again use the <code>rasterize()</code> command to assign a value to every gridcell according to its <code>adm2</code> location, but this time use the <code>pop15</code> variable.</p>
<pre><code class="language-r">yet_another_new_raster &lt;- command(adm2, template_raster, field = &quot;pop15&quot;)
</code></pre>
<p>Distribute the <code>adm2</code> populatoin totals across each gridcell according to its fractional proportion of summed predicted population (also at <code>adm2</code>), multiply the proportion by the totals.</p>
<pre><code class="language-text">population &lt;- gridcell_proportions * population_adm2
</code></pre>
<p>Confirm your results by evaluating the totals.</p>
<pre><code class="language-text">cellStats(population, sum)
[1] 4039128
</code></pre>
<p>R should return the same total previously used when you calcualte <code>sum(your_adm2$pop15)</code>.</p>
<p><img src="images/rplot01%20%289%29.png" alt="" /></p>
<h2><a class="header" href="#investigate-margins-of-error" id="investigate-margins-of-error">Investigate Margins of Error</a></h2>
<p>Our model is serving to allocate population totals across all gridcells, but how accurate is it?  To start we can calculate the different of our predicted values - the worldpop values and sum the totals.</p>
<pre><code class="language-text">diff &lt;- population - lbr_pop15
</code></pre>
<p>In order to establish a basis for comparing total error across your LMIC take the absolute value of the differences and sum them to arrive a term that represnts total error.</p>
<pre><code class="language-text">cellStats(abs(diff), sum)
</code></pre>
<p>Taking the <code>hist(diff)</code> will also inform you of the magnitude and direction of error in your predicted values.  Use the <code>plot(diff)</code> command to have a look at the resulting raster.</p>
<p><img src="images/rplot02%20%285%29.png" alt="" /></p>
<p>By looking at the histogram and the above difference of predicted value from worldpop raster it appears that most of the error is slightly above or below 0, and is also distributed fairly evenly across the entire space.  Looking closely though, the area close to the southwest coast appears to exhibit a different phenomenon.  This is the capital of Liberia, Monrovia.  For your investigation, select the primary urban area and conduct the same analysis as follows.</p>
<p>First subset your <code>adm2</code> by using the name of the administrative subdivision.</p>
<pre><code class="language-text">new_name &lt;- your_adm2 %&gt;%
  filter(name_var == &quot;Add Name Here&quot;)
</code></pre>
<p>Use the <code>mask()</code> command with this newly created <code>sf</code> object to focus your analysis on the primate city within your LMIC.</p>
<pre><code class="language-text">urban_diff &lt;- mask(diff, urban_adm2)
urban_pop &lt;- mask(population, urban_adm2)
</code></pre>
<p>Create an object the defines the boundaries of your identified urban area.  The bounding box used in your <code>crop()</code> command should be defined according the following order.</p>
<pre><code class="language-text">c(western_most_longitude, eastern_most_longitude, southern_most_latitude, northern_most_latitude)
</code></pre>
<p>Following is the bounding box and <code>crop()</code> command used for Monrovia, Liberia.</p>
<pre><code class="language-text">extGMN &lt;- c(-10.83, -10.64, 6.20, 6.42)
gmonrovia_diff &lt;- crop(gmonrovia_diff, extGMN)
gmonrovia_pop &lt;- crop(gmonrovia_pop, extGMN)
</code></pre>
<p>Plot your Monrovia rasters.</p>
<p><img src="images/rplot03%20%285%29.png" alt="Error in terms of Predicted Values - WorldPop estimates" /></p>
<p><img src="images/rplot04%20%283%29.png" alt="" /></p>
<p>Finally, plot a three dimension map of the values, to gauge exactly how much variation was exhibited in the predicted values.  Install and load the <code>rgl::</code> and <code>rasterVis::</code> libraries in order to execute the following command.</p>
<pre><code class="language-text">rasterVis::plot3D(gmonrovia_pop)
</code></pre>
<p><img src="images/screen-shot-2019-10-07-at-12.26.00-am.png" alt="" /></p>
<p>Finally, add the <code>tmap::</code> library and overlay your differences plot.</p>
<pre><code class="language-r">mapview::mapview(gmonrovia_diff, alpha = .5)
</code></pre>
<p>Do you identify a geospatial trend associated with the error resulting from your predicted values?</p>
<p><img src="images/rplot07%20%282%29.png" alt="" /></p>
<h2><a class="header" href="#team-challenge-question-1" id="team-challenge-question-1">Team Challenge Question</a></h2>
<p>Follow the steps from above used to produce the plots describing Liberia, but instead each team member should use their own selected LMIC country.  Investigate the results from your model at different scales and locations across your selected LMIC.  How effective was your model?  Do you identify any trends?  Produce a variety of plots that investigate, describe and analyze your dasymmetric population allocation using a linear model with land use and land cover geospatial covariates.  Investigate at least two different locations and two different scales.  Use adm1, adm2 or adm3 units of analysis, either in combination or alone to define the boundaries of your analysis.</p>
<p>Meet with your group and prepare to present three different plots from at least three different countries (or team members) for the Friday informal group presentation.  You are welcome to combine output from the previous Project 2 exercise (part 1) as you wish.  Then as a group, upload all 5 team members plots to #data100_igps (informal group presentations) by Sunday night.  Each member should upload at least <strong>four plots</strong> that describe <strong>at least two different locations of differing scales</strong> within your LMIC.</p>
<h1><a class="header" href="#investigating-and-comparing-results" id="investigating-and-comparing-results">Investigating and Comparing Results</a></h1>
<p>Load all of your covariates, import your adm0 (international boundary) to <code>crop()</code> and <code>mask()</code> your <code>RasterBrick</code> and then use <code>writeRaster()</code> to save it.  Later, use the <code>brick()</code> function to import your <code>RasterBrick</code> to your RStudio work session as needed.  Make sure the layers in your <code>RasterBrick</code> are named after using the <code>brick()</code> command.  Use the <code>names()</code> command to name your layers.</p>
<pre><code class="language-r">f &lt;- list.files(pattern=&quot;lbr_esaccilc_dst&quot;, recursive=TRUE)
lulc &lt;- stack(lapply(f, function(i) raster(i, band=1)))
nms &lt;- sub(&quot;_100m_2015.tif&quot;, &quot;&quot;, sub(&quot;lbr_esaccilc_&quot;, &quot;&quot;, f))
names(lulc) &lt;- nms
topo &lt;- raster(&quot;lbr_srtm_topo_100m.tif&quot;)
slope &lt;- raster(&quot;lbr_srtm_slope_100m.tif&quot;)
ntl &lt;- raster(&quot;lbr_viirs_100m_2015.tif&quot;)
lulc &lt;- addLayer(lulc, topo, slope, ntl)
names(lulc)[c(1,10:12)] &lt;- c(&quot;water&quot;,&quot;topo&quot;,&quot;slope&quot;, &quot;ntl&quot;)

lbr_adm0  &lt;- read_sf(&quot;gadm36_LBR_0.shp&quot;)

lulc &lt;- crop(lulc, lbr_adm0)
lulc &lt;- mask(lulc, lbr_adm0)

writeRaster(lulc, filename = &quot;lulc.tif&quot;, overwrite = TRUE)
# lulc &lt;- stack(&quot;lulc.tif&quot;)
lulc &lt;- brick(&quot;lulc.tif&quot;)

names(lulc) &lt;- c(&quot;water&quot;, &quot;dst011&quot; , &quot;dst040&quot;, &quot;dst130&quot;, &quot;dst140&quot;, &quot;dst150&quot;, 
                 &quot;dst160&quot;, &quot;dst190&quot;, &quot;dst200&quot;, &quot;topo&quot;, &quot;slope&quot;, &quot;ntl&quot;)
</code></pre>
<p>Obtain the 2015 WorldPop persons per pixel file for your LMIC.  Make sure your adm <code>sf</code> object has the total population per subdivision as well as its area and density.  Summarize all twelve geospatial covariates in adm groups by <code>sum</code> and by <code>mean</code>.  Modify the following code to create your adm2 or adm3 object (you only have to select one, in the following example I have selected adm3 for Liberia).</p>
<pre><code class="language-r">lbr_pop15 &lt;- raster(&quot;lbr_ppp_2015.tif&quot;)
# lbr_adm1  &lt;- read_sf(&quot;gadm36_LBR_1.shp&quot;)
# lbr_adm2  &lt;- read_sf(&quot;gadm36_LBR_2.shp&quot;)
lbr_adm3  &lt;- read_sf(&quot;gadm36_LBR_3.shp&quot;)

# ncores &lt;- detectCores() - 1
# beginCluster(ncores)
# pop_vals_adm1 &lt;- raster::extract(lbr_pop15, lbr_adm1, df = TRUE)
# pop_vals_adm2 &lt;- raster::extract(lbr_pop15, lbr_adm2, df = TRUE)
# pop_vals_adm3 &lt;- raster::extract(lbr_pop15, lbr_adm3, df = TRUE)
# endCluster()
# save(pop_vals_adm1, pop_vals_adm2, pop_vals_adm3, file = &quot;lbr_pop_vals.RData&quot;)

load(&quot;lbr_pop_vals.RData&quot;)

# totals_adm1 &lt;- pop_vals_adm1 %&gt;%
#   group_by(ID) %&gt;%
#   summarize(pop15 = sum(lbr_ppp_2015, na.rm = TRUE))
# 
# lbr_adm1 &lt;- lbr_adm1 %&gt;%
#   add_column(pop15 = totals_adm1$pop15)
# 
# lbr_adm1 &lt;- lbr_adm1 %&gt;%
#   mutate(area = st_area(lbr_adm1) %&gt;%
#            set_units(km^2)) %&gt;%
#   mutate(density = pop15 / area)

# totals_adm2 &lt;- pop_vals_adm2 %&gt;%
#   group_by(ID) %&gt;%
#   summarize(pop15 = sum(lbr_ppp_2015, na.rm = TRUE))
# 
# lbr_adm2 &lt;- lbr_adm2 %&gt;%
#   add_column(pop15 = totals_adm2$pop15)
# 
# lbr_adm2 &lt;- lbr_adm2 %&gt;%
#   mutate(area = st_area(lbr_adm2) %&gt;%
#            set_units(km^2)) %&gt;%
#   mutate(density = pop15 / area)

totals_adm3 &lt;- pop_vals_adm3 %&gt;%
  group_by(ID) %&gt;%
  summarize(pop15 = sum(lbr_ppp_2015, na.rm = TRUE))

lbr_adm3 &lt;- lbr_adm3 %&gt;%
  add_column(pop15 = totals_adm3$pop15)

lbr_adm3 &lt;- lbr_adm3 %&gt;%
  mutate(area = st_area(lbr_adm3) %&gt;% 
           set_units(km^2)) %&gt;%
  mutate(density = pop15 / area)

#save(lbr_adm1, lbr_adm2, lbr_adm3, file = &quot;lbr_adms.RData&quot;)

# lulc &lt;- brick(&quot;lulc.tif&quot;)

# names(lulc) &lt;- c(&quot;water&quot;, &quot;dst011&quot; , &quot;dst040&quot;, &quot;dst130&quot;, &quot;dst140&quot;, &quot;dst150&quot;, 
#                 &quot;dst160&quot;, &quot;dst190&quot;, &quot;dst200&quot;, &quot;topo&quot;, &quot;slope&quot;, &quot;ntl&quot;)

# ncores &lt;- detectCores() - 1
# beginCluster(ncores)
# lulc_vals_adm1 &lt;- raster::extract(lulc, lbr_adm1, df = TRUE)
# lulc_vals_adm2 &lt;- raster::extract(lulc, lbr_adm2, df = TRUE)
# lulc_vals_adm3 &lt;- raster::extract(lulc, lbr_adm3, df = TRUE)
# endCluster()
# save(lulc_vals_adm1, lulc_vals_adm2, lulc_vals_adm3, file = &quot;lulc_vals_adms.RData&quot;)

load(&quot;lulc_vals_adms.RData&quot;)

# lulc_ttls_adm1 &lt;- lulc_vals_adm1 %&gt;%
#   group_by(ID) %&gt;%
#   summarize_all(sum, na.rm = TRUE)

# lulc_ttls_adm2 &lt;- lulc_vals_adm2 %&gt;%
#   group_by(ID) %&gt;%
#   summarize_all(sum, na.rm = TRUE)

lulc_ttls_adm3 &lt;- lulc_vals_adm3 %&gt;%
  group_by(ID) %&gt;%
  summarize_all(sum, na.rm = TRUE)

lulc_means_adm3 &lt;- lulc_vals_adm3 %&gt;%
  group_by(ID) %&gt;%
  summarize_all(mean, na.rm = TRUE)

# lbr_adm1 &lt;- bind_cols(lbr_adm1, lulc_ttls_adm1)
# lbr_adm2 &lt;- bind_cols(lbr_adm2, lulc_ttls_adm2)

lbr_adm3 &lt;- bind_cols(lbr_adm3, lulc_ttls_adm3, lulc_means_adm3)

save(lbr_adm3, file = &quot;lbr_adm3.RData&quot;)
</code></pre>
<p>Load your geospatial covariate <code>RasterBrick</code> of land use and land cover <code>lulc</code>, your 2015 WorldPop <code>raster</code> and  your adm <code>sf</code> object.  View your adm <code>sf</code> object and notice that you now have two summary sets of columns that describe each of your twelve geospatial covariates.  The first set of columns describes the sum of all values per adm while the second set describes the mean of all values per adm.  Also notice that in the second set, each variable  has had the number 1 added to its name to differentiate it from the first series.</p>
<p>Use the <code>lm()</code> function to estimate three models.  First use <code>pop15</code> as the response variable and the <code>sum</code> of each geospatial covariate per adm as the predictors.  Second, again use <code>pop15</code> as the response variable but this time instead use the <code>mean</code> of each geospatial covariate per adm as the predictors.  Third, use the logarithm of 2015 population <code>log(pop15)</code> as the response and the <code>mean</code> of each geospatial covariate per adm as the predictors.  Notice I created a new variable named <code>logpop15</code> but you could just as easily have specified <code>log(pop15)</code> within the call of your model.</p>
<pre><code class="language-r">model.sums &lt;- lm(pop15 ~ water + dst011 + dst040 + dst130 + dst140 + dst150 + dst160 + dst190 + dst200 + topo + slope + ntl, data=lbr_adm3)
model.means &lt;- lm(pop15 ~ water1 + dst0111 + dst0401 + dst1301 + dst1401 + dst1501 + dst1601 + dst1901 + dst2001 + topo1 + slope1 + ntl1, data=lbr_adm3)

lbr_adm3$logpop15 &lt;- log(lbr_adm3$pop15)
model.logpop15 &lt;- lm(logpop15 ~ water1 + dst0111 + dst0401 + dst1301 + dst1401 + dst1501 + dst1601 + dst1901 + dst2001 + topo1 + slope1 + ntl1, data=lbr_adm3)
</code></pre>
<p>Check the summary output from each model.</p>
<pre><code class="language-r">summary(model.sums)
summary(model.means)
summary(model.logpop15)
</code></pre>
<p>Make sure the names of each layer in your <code>RasterBrick</code> matches the names of the independent variables in each of your models.  Notice how the second two models use the <code>mean</code> of each geospatial covarariate and the layer names are modified accordingly to match.</p>
<pre><code class="language-r">names(lulc) &lt;- c(&quot;water&quot;, &quot;dst011&quot; , &quot;dst040&quot;, &quot;dst130&quot;, &quot;dst140&quot;, &quot;dst150&quot;, &quot;dst160&quot;, &quot;dst190&quot;, &quot;dst200&quot;, &quot;topo&quot;, &quot;slope&quot;, &quot;ntl&quot;)
lulc1 &lt;- lulc
names(lulc1) &lt;- c(&quot;water1&quot;, &quot;dst0111&quot; , &quot;dst0401&quot;, &quot;dst1301&quot;, &quot;dst1401&quot;, &quot;dst1501&quot;, &quot;dst1601&quot;, &quot;dst1901&quot;, &quot;dst2001&quot;, &quot;topo1&quot;, &quot;slope1&quot;, &quot;ntl1&quot;)
</code></pre>
<p>Use the <code>predict()</code> function from the <code>raster::</code> package with the appropriate <code>RasterBrick</code> and <code>model</code> to predict each gridcells value.  Use the <code>save()</code> and then the <code>load()</code> command in order to reduce computation time after restarting your work session. </p>
<pre><code class="language-r">predicted_values_sums &lt;- raster::predict(lulc, model.sums)
predicted_values_means &lt;- raster::predict(lulc1, model.means)
predicted_values_logpop15 &lt;- raster::predict(lulc1, model.logpop15)

#save(predicted_values_sums, predicted_values_means, predicted_values_logpop15, file = &quot;predicted_values.RData&quot;)
</code></pre>
<p>Use the <code>extract()</code> function from the <code>raster::</code> package to assign the adm ID to each gridcell.  Again use the <code>save()</code> and <code>load()</code> commands to reduce computation time.</p>
<pre><code class="language-r">ncores &lt;- detectCores() - 1
beginCluster(ncores)
pred_vals_adm3_sums &lt;- raster::extract(predicted_values_sums, lbr_adm3, df=TRUE)
pred_vals_adm3_means &lt;- raster::extract(predicted_values_means, lbr_adm3, df=TRUE)
pred_vals_adm3_logpop15 &lt;- raster::extract(predicted_values_logpop15, lbr_adm3, df=TRUE)
endCluster()

#save(pred_vals_adm3_sums, pred_vals_adm3_means, pred_vals_adm3_logpop15, file = &quot;predicted_values_adm3s.RData&quot;)
</code></pre>
<p>Aggregate all values.</p>
<pre><code class="language-r">pred_ttls_adm3_sums &lt;- aggregate(. ~ ID, pred_vals_adm3_sums, sum)
pred_ttls_adm3_means &lt;- aggregate(. ~ ID, pred_vals_adm3_means, sum)
pred_ttls_adm3_logpop15 &lt;- aggregate(. ~ ID, pred_vals_adm3_logpop15, sum)
</code></pre>
<p>Create a new data frame that contains the aggregate sums from each model's predictions.</p>
<pre><code class="language-r">ttls &lt;- cbind.data.frame(preds_sums = pred_ttls_adm3_sums$layer, 
                         preds_means = pred_ttls_adm3_means$layer, 
                         resp_logpop = pred_ttls_adm3_logpop15$layer)
</code></pre>
<p>Bind the new values as columns within your adm.  Notice I assigned a name to each column.</p>
<pre><code class="language-r">lbr_adm3 &lt;- bind_cols(lbr_adm3, ttls)
</code></pre>
<p>Use the <code>rasterize()</code> command to create a new <code>RasterLayer</code> containing the predicted values from each of your models.  The second object in your <code>rasterize()</code> command is the raster that is used as the template to produce the new raster.  The values of the template raster are not used in the calculation, instead the values in the column of your adm <code>sf</code> object that identify the sum of predicted values from your model is used. </p>
<pre><code class="language-r">predicted_totals_sums &lt;- rasterize(lbr_adm3, predicted_values_sums, field = &quot;preds_sums&quot;)
predicted_totals_means &lt;- rasterize(lbr_adm3, predicted_values_sums, field = &quot;preds_means&quot;)
predicted_totals_logpop &lt;- rasterize(lbr_adm3, predicted_values_sums, field = &quot;resp_logpop&quot;)
</code></pre>
<p>Calculate the gridcell proportions for each result.</p>
<pre><code class="language-r">gridcell_proportions_sums  &lt;- predicted_values_sums / predicted_totals_sums
gridcell_proportions_means  &lt;- predicted_values_means / predicted_totals_means
gridcell_proportions_logpop  &lt;- predicted_values_logpop15 / predicted_totals_logpop
</code></pre>
<p>Check the <code>cellStats()</code> to confirm that the sum of each objects proportions is equal to the number of adms in your <code>sf</code> object.</p>
<pre><code class="language-r">cellStats(gridcell_proportions_sums, sum)
cellStats(gridcell_proportions_means, sum)
cellStats(gridcell_proportions_logpop, sum)
</code></pre>
<p>Produce a raster object that contains the WorldPop values we will use as our comparison spatial data set for validation.</p>
<pre><code class="language-r">population_adm3 &lt;- rasterize(lbr_adm3, predicted_values_sums, field = &quot;pop15&quot;)
</code></pre>
<p>Calculate the final predicted value for each gridcell according to the output from each of the three models.</p>
<pre><code class="language-r">population_sums &lt;- gridcell_proportions_sums * population_adm3
population_means &lt;- gridcell_proportions_means * population_adm3
population_logpop &lt;- gridcell_proportions_logpop * population_adm3
</code></pre>
<p>Check <code>cellStats()</code> to verify that total population matches the initial value used in this dasymmetric allocation.</p>
<pre><code class="language-text">cellStats(population_sums, sum)
cellStats(population_means, sum)
cellStats(population_logpop, sum)

sum(lbr_adm3$pop15)
</code></pre>
<p>Calculate the difference between each <code>RasterLayer</code> and the WorldPop <code>RasterLayer</code>.</p>
<pre><code class="language-r">diff_sums &lt;- population_sums - lbr_pop15
diff_means &lt;- population_means - lbr_pop15
diff_logpop &lt;- population_logpop - lbr_pop15
</code></pre>
<p>Finally, produce a raster plot of each model's predicted output as well as the differences and a 3D plot to visualize the results.</p>
<pre><code class="language-r">plot(population_sums)
plot(diff_sums)
rasterVis::plot3D(diff_sums)
cellStats(abs(diff_sums), sum)

plot(population_means)
plot(diff_means)
rasterVis::plot3D(diff_means)
cellStats(abs(diff_means), sum)

plot(population_logpop)
plot(diff_logpop)
rasterVis::plot3D(diff_logpop)
cellStats(abs(diff_logpop), sum)

plot(lbr_pop15)

rgl.snapshot(&quot;diff&quot;, fmt = &quot;png&quot;, top = TRUE )
</code></pre>
<p><img src="images/rplot%20%286%29.png" alt="Population: Predictors - Sums" /></p>
<p><img src="images/rplot10.png" alt="Difference: Predictors - Sums" /></p>
<p><img src="images/diff1.png" alt="3D Difference: Predictors - Sums" /></p>
<p><img src="images/rplot11.png" alt="Population: Predictors - Means" /></p>
<p><img src="images/rplot12.png" alt="Difference: Predictors - Means" /></p>
<p><img src="images/diff2.png" alt="3D Difference: Predictors - Means" /></p>
<p><img src="images/rplot13.png" alt="Population: Response - Log of Population" /></p>
<p><img src="images/rplot14.png" alt="Difference: Response - Log of Population " /></p>
<p><img src="images/diff.png" alt="3D Difference: Response - Log of Population " /></p>
<h2><a class="header" href="#project-2-individual-deliverable" id="project-2-individual-deliverable">Project 2. Individual Deliverable</a></h2>
<p>Upload three sets of spatial plots that describe the predicted population of your selected LMIC using each of the three models.</p>
<ol>
<li>Response variable is population and the predictors are sum of covariates</li>
<li>Response variable is population and the predictors are mean of covariates</li>
<li>Reponse variable is log of population and the predictors are mean of covariates</li>
</ol>
<p>Each of the three sets of plots should also have three plots.</p>
<ol>
<li>A plot that describes the predicted population of your LMIC using the model</li>
<li>A plot that describes the difference between your predicted results and the WorldPop estimates for 2015</li>
<li>A three dimension plot that visualizes the population or difference</li>
</ol>
<p>Accompany your series of plots with a written statement that identifies which of the three models produced the best results.  Justify your assessment. </p>
<p>Upload your deliverable to the slack channel #data100_project2 no later than 11:59PM on Sunday, October 20th.</p>
<h2><a class="header" href="#individual-stretch-goal-1-1" id="individual-stretch-goal-1-1">Individual Stretch Goal 1</a></h2>
<p>Conduct the same analysis as above at an increased scale, analyzing one of your LMIC's largest or most significant urban areas or cities.  Subset your adm using the <code>%&gt;%</code> operator and the <code>|</code> as needed.</p>
<pre><code class="language-r">mts_bomi &lt;- lbr_adm3 %&gt;%
 filter(NAME_1 == &quot;Montserrado&quot; | NAME_1 == &quot;Bomi&quot;)
</code></pre>
<p>Use the <code>mapview()</code> command to identify trends and provide further support for your assessment of each model as you did in the previous execise.</p>
<pre><code class="language-r">mapview::mapview(gmonrovia_diff, alpha = .5)
</code></pre>
<p>Again compare the results.  Are you able to identify any trends?</p>
<h2><a class="header" href="#individual-stretch-goal-2" id="individual-stretch-goal-2">Individual Stretch Goal 2</a></h2>
<p>Estimate a random forest model using the same data you previously used.  Use the mean values of all grid cells within each adm as the predictors (independent variable) and the log of population as the response (dependent variable).  Start by loading the World Pop raster you will use to validate your resuts against first.  Then load your adm0 to use in your <code>crop()</code> and <code>mask()</code> commands.  Load your adm3 that has all of your variables needed to estimate your random forest model.  Also be sure to load the land use and land cover variables you will use to predict the population of each individual grid cell.</p>
<pre><code class="language-text">rm(list=ls(all=TRUE))

# install.packages(&quot;raster&quot;, dependencies = TRUE)
# install.packages(&quot;sf&quot;, dependencies = TRUE)
# install.packages(&quot;tidyverse&quot;, dependencies = TRUE)
# install.packages(&quot;doParallel&quot;, dependencies = TRUE)
# install.packages(&quot;snow&quot;, dependencies = TRUE)
# install.packages(&quot;randomForest&quot;, dependencies = TRUE)

#library(sp)
library(sf)
library(raster)
library(tidyverse)
library(doParallel)
library(snow)
library(randomForest)

### Import Administrative Boundaries ###

setwd(&quot;~/Tresors/teaching/project_folder/data/&quot;)

lbr_pop15 &lt;- raster(&quot;lbr_ppp_2015.tif&quot;)

lbr_adm0  &lt;- read_sf(&quot;gadm36_LBR_0.shp&quot;)
load(&quot;lbr_adm3.RData&quot;)

lulc &lt;- brick(&quot;lulc.tif&quot;)

lulc &lt;- crop(lulc, lbr_adm0)
lulc &lt;- mask(lulc, lbr_adm0)
</code></pre>
<p>Simplify your adm3 by extracting only the needed columns.  Remove the geometry from the object by using the <code>st_geometry()</code> command and assigning it as <code>NULL</code>.  Add the log of population as a variable to your newly created data set.  Simply the class of your data set by rewriting it as a <code>data.frame</code>.</p>
<pre><code class="language-text">model_data &lt;- lbr_adm3[ ,c(18:20, 35:46)]
st_geometry(model_data) &lt;- NULL
model_data$logpop15 &lt;- as.numeric(log(model_data$pop15))
model_data &lt;- as.data.frame(model_data)
</code></pre>
<p>Your object <code>model_data</code> should have the following structure.</p>
<p><img src="images/screen-shot-2019-10-21-at-11.23.53-pm.png" alt="" /></p>
<p>Simplify the objects you will use as the predictors and response by creating two new objects.  The <code>x_data</code> object are your predictors and coorespond to the mean values of each <code>lulc</code> variable at each adm.  The <code>y_data</code> is your response variable, in this case log of population.</p>
<pre><code class="language-text">x_data &lt;- model_data[ ,4:15]
y_data &lt;- model_data[ ,16]
</code></pre>
<p>First, tune your random forest model in order to determine which of the variables are important.  The <code>ntreeTry =</code>  argument specifies how many trees the model will estimate at the tuning step.  The <code>mtryStart =</code>  argument specifies how many variables will be tried at each split.  Other arguments are also important, but you can simply follow the following chunk of code to start.</p>
<pre><code class="language-text">init_fit &lt;- tuneRF(x = x_data, 
                   y = y_data,
                   plot = TRUE,
                   mtryStart = length(x_data)/3,
                   ntreeTry = length(y_data)/20,
                   imrpove = 0.0001,
                   stepFactor = 1.20,
                   trace = TRUE,
                   doBest = TRUE,
                   nodesize = length(y_data)/1000,
                   na.action = na.omit,
                   importance = TRUE,
                   proximity = TRUE,
                   sampsize = min(c(length(y_data), 1000)),
                   replace = TRUE)
</code></pre>
<p>After you get a result from your tuning step, check the importance scores from your model.  Use <code>importance(init_fit)</code> to have RStudio return measures for each variable.  Assign those scores to a vector and then subset using subscripting operators all variables that have a positive value.  Retain only those variables that have a positive importance score. </p>
<pre><code class="language-text">importance_scores &lt;- importance(init_fit)
pos_importance &lt;- rownames(importance_scores)[importance_scores[ ,1] &gt; 0]
pos_importance

x_data &lt;- x_data[pos_importance]
</code></pre>
<p>After respecifying your random forest model, estimate it again.</p>
<pre><code class="language-text">pop_fit &lt;- tuneRF(x = x_data,
                  y = y_data,
                  plot = TRUE,
                  mtryStart = length(x_data)/3,
                  ntreeTry = length(y_data)/20,
                  imrpove = 0.0001,
                  stepFactor = 1.20,
                  trace = TRUE,
                  doBest = TRUE,
                  nodesize = length(y_data)/1000,
                  na.action = na.omit,
                  importance = TRUE,
                  proximity = TRUE,
                  sampsize = min(c(length(y_data), 1000)),
                  replace = TRUE)
</code></pre>
<p>Finally, use several of the parameters from <code>pop_fit</code> in the arguments of your final model.</p>
<pre><code class="language-text">model &lt;- randomForest(x = x_data,
                      y = y_data,
                      mtry=pop_fit$mtry,
                      ntree = pop_fit$ntree,
                      nodesize = length(y_data)/1000,
                      importance = TRUE,
                      proximity = TRUE,
                      do.trace = FALSE)
</code></pre>
<p>Check the output from your model.</p>
<pre><code class="language-text">print(model)
plot(model)
varImpPlot(model)
</code></pre>
<p><img src="images/screen-shot-2019-10-21-at-11.40.59-pm.png" alt="Capacity of RF model to explain variance with its 500 trees" /></p>
<p><img src="images/rplot.png" alt="Number of trees needed before Out of Bag Error stabilized" /></p>
<p><img src="images/rplot01.png" alt="Two measures of importance for each of the predictor variables" /></p>
<p>Confirm that the names in your random forest model match those found in your <code>rasterBrick</code>.</p>
<pre><code class="language-text">names(lulc) &lt;- c(&quot;water1&quot;, &quot;dst0111&quot; , &quot;dst0401&quot;, &quot;dst1301&quot;, &quot;dst1401&quot;, &quot;dst1501&quot;, &quot;dst1601&quot;, &quot;dst1901&quot;, &quot;dst2001&quot;, &quot;topo1&quot;, &quot;slope1&quot;, &quot;ntl1&quot;)
</code></pre>
<p>Now predict your population values using the model with the 12 different geospatial covariate layers.</p>
<pre><code class="language-text">preds_rf &lt;- raster::predict(lulc, model)
</code></pre>
<p>After you have predicted your population values for each gridcell, back transform the log of population to its original estimate.</p>
<pre><code class="language-text">preds_rf_exp &lt;- exp(preds_rf)
</code></pre>
<p>Next, extract all of the predicted values by assigning the ID for each adm unit where it is located.</p>
<pre><code class="language-text">ncores &lt;- detectCores() - 1
beginCluster(ncores)
preds_ttls_rf &lt;- raster::extract(preds_rf_exp, lbr_adm3, df=TRUE)
endCluster()
</code></pre>
<p>Aggregate all of the values by adm ID and sum.</p>
<pre><code class="language-text">preds_area_totals_rf &lt;- aggregate(. ~ ID, preds_ttls_rf, sum)
</code></pre>
<p>Bind the columns.</p>
<pre><code class="language-text">lbr_adm3 &lt;- bind_cols(lbr_adm3, preds_area_totals_rf)
</code></pre>
<p>Finally, <code>rasterize()</code> the value of the total estimates per adm and then calculate the gridcell proportionate share across the entire LMIC.  Confirm that <code>cellStats()</code> returns a value equal to the number of adms in your LMIC.</p>
<pre><code class="language-text">preds_ttls &lt;- rasterize(lbr_adm3, preds_rf, field = &quot;layer&quot;)
props  &lt;- preds_rf_exp / preds_ttls
cellStats(props, sum)
</code></pre>
<p>Again, <code>rasterize()</code> population values and then multiply the gridcell proportions by the population values to estimate each gridcells proportion of the total population per gridcell.</p>
<pre><code class="language-text">pops &lt;- rasterize(lbr_adm3, preds_rf, field = &quot;pop15&quot;)
gridcell_pops &lt;- props * pops
cellStats(gridcell_pops, sum)
</code></pre>
<p>Check <code>cellStats()</code> to confirm your totals match population values calculated from the WorldPop persons per pixel raster layer.</p>
<p>Finally, subtract the raster layer with predicted values from your random forest model from the WorldPop ppp raster layer.  Calculate the sum of absolute value of differences between the two rasters.</p>
<pre><code class="language-text">diff &lt;- gridcell_pops - lbr_pop15
cellStats(abs(diff), sum)

rasterVis::plot3D(gridcell_pops)
rasterVis::plot3D(diff)
</code></pre>
<p>What can you surmise?  Have you improved your predictive power by applying a machine learning approach?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="describe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="describe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
